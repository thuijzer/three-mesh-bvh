{"mappings":"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","sources":["node_modules/three/examples/jsm/geometries/RoundedBoxGeometry.js"],"sourcesContent":["import {\n\tBoxGeometry,\n\tVector3\n} from 'three';\n\nconst _tempNormal = new Vector3();\n\nfunction getUv( faceDirVector, normal, uvAxis, projectionAxis, radius, sideLength ) {\n\n\tconst totArcLength = 2 * Math.PI * radius / 4;\n\n\t// length of the planes between the arcs on each axis\n\tconst centerLength = Math.max( sideLength - 2 * radius, 0 );\n\tconst halfArc = Math.PI / 4;\n\n\t// Get the vector projected onto the Y plane\n\t_tempNormal.copy( normal );\n\t_tempNormal[ projectionAxis ] = 0;\n\t_tempNormal.normalize();\n\n\t// total amount of UV space alloted to a single arc\n\tconst arcUvRatio = 0.5 * totArcLength / ( totArcLength + centerLength );\n\n\t// the distance along one arc the point is at\n\tconst arcAngleRatio = 1.0 - ( _tempNormal.angleTo( faceDirVector ) / halfArc );\n\n\tif ( Math.sign( _tempNormal[ uvAxis ] ) === 1 ) {\n\n\t\treturn arcAngleRatio * arcUvRatio;\n\n\t} else {\n\n\t\t// total amount of UV space alloted to the plane between the arcs\n\t\tconst lenUv = centerLength / ( totArcLength + centerLength );\n\t\treturn lenUv + arcUvRatio + arcUvRatio * ( 1.0 - arcAngleRatio );\n\n\t}\n\n}\n\nclass RoundedBoxGeometry extends BoxGeometry {\n\n\tconstructor( width = 1, height = 1, depth = 1, segments = 2, radius = 0.1 ) {\n\n\t\t// ensure segments is odd so we have a plane connecting the rounded corners\n\t\tsegments = segments * 2 + 1;\n\n\t\t// ensure radius isn't bigger than shortest side\n\t\tradius = Math.min( width / 2, height / 2, depth / 2, radius );\n\n\t\tsuper( 1, 1, 1, segments, segments, segments );\n\n\t\t// if we just have one segment we're the same as a regular box\n\t\tif ( segments === 1 ) return;\n\n\t\tconst geometry2 = this.toNonIndexed();\n\n\t\tthis.index = null;\n\t\tthis.attributes.position = geometry2.attributes.position;\n\t\tthis.attributes.normal = geometry2.attributes.normal;\n\t\tthis.attributes.uv = geometry2.attributes.uv;\n\n\t\t//\n\n\t\tconst position = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\tconst box = new Vector3( width, height, depth ).divideScalar( 2 ).subScalar( radius );\n\n\t\tconst positions = this.attributes.position.array;\n\t\tconst normals = this.attributes.normal.array;\n\t\tconst uvs = this.attributes.uv.array;\n\n\t\tconst faceTris = positions.length / 6;\n\t\tconst faceDirVector = new Vector3();\n\t\tconst halfSegmentSize = 0.5 / segments;\n\n\t\tfor ( let i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\n\n\t\t\tposition.fromArray( positions, i );\n\t\t\tnormal.copy( position );\n\t\t\tnormal.x -= Math.sign( normal.x ) * halfSegmentSize;\n\t\t\tnormal.y -= Math.sign( normal.y ) * halfSegmentSize;\n\t\t\tnormal.z -= Math.sign( normal.z ) * halfSegmentSize;\n\t\t\tnormal.normalize();\n\n\t\t\tpositions[ i + 0 ] = box.x * Math.sign( position.x ) + normal.x * radius;\n\t\t\tpositions[ i + 1 ] = box.y * Math.sign( position.y ) + normal.y * radius;\n\t\t\tpositions[ i + 2 ] = box.z * Math.sign( position.z ) + normal.z * radius;\n\n\t\t\tnormals[ i + 0 ] = normal.x;\n\t\t\tnormals[ i + 1 ] = normal.y;\n\t\t\tnormals[ i + 2 ] = normal.z;\n\n\t\t\tconst side = Math.floor( i / faceTris );\n\n\t\t\tswitch ( side ) {\n\n\t\t\t\tcase 0: // right\n\n\t\t\t\t\t// generate UVs along Z then Y\n\t\t\t\t\tfaceDirVector.set( 1, 0, 0 );\n\t\t\t\t\tuvs[ j + 0 ] = getUv( faceDirVector, normal, 'z', 'y', radius, depth );\n\t\t\t\t\tuvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'z', radius, height );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1: // left\n\n\t\t\t\t\t// generate UVs along Z then Y\n\t\t\t\t\tfaceDirVector.set( - 1, 0, 0 );\n\t\t\t\t\tuvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'z', 'y', radius, depth );\n\t\t\t\t\tuvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'z', radius, height );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2: // top\n\n\t\t\t\t\t// generate UVs along X then Z\n\t\t\t\t\tfaceDirVector.set( 0, 1, 0 );\n\t\t\t\t\tuvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'x', 'z', radius, width );\n\t\t\t\t\tuvs[ j + 1 ] = getUv( faceDirVector, normal, 'z', 'x', radius, depth );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3: // bottom\n\n\t\t\t\t\t// generate UVs along X then Z\n\t\t\t\t\tfaceDirVector.set( 0, - 1, 0 );\n\t\t\t\t\tuvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'x', 'z', radius, width );\n\t\t\t\t\tuvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'z', 'x', radius, depth );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 4: // front\n\n\t\t\t\t\t// generate UVs along X then Y\n\t\t\t\t\tfaceDirVector.set( 0, 0, 1 );\n\t\t\t\t\tuvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'x', 'y', radius, width );\n\t\t\t\t\tuvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'x', radius, height );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 5: // back\n\n\t\t\t\t\t// generate UVs along X then Y\n\t\t\t\t\tfaceDirVector.set( 0, 0, - 1 );\n\t\t\t\t\tuvs[ j + 0 ] = getUv( faceDirVector, normal, 'x', 'y', radius, width );\n\t\t\t\t\tuvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'x', radius, height );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexport { RoundedBoxGeometry };\n"],"names":["$8be04d874cd74072$var$_tempNormal","$hGT0Q","Vector3","$8be04d874cd74072$var$getUv","faceDirVector","normal","uvAxis","projectionAxis","radius","sideLength","totArcLength","Math","PI","centerLength","max","halfArc","copy","normalize","arcUvRatio","arcAngleRatio","angleTo","sign","$8be04d874cd74072$export$418f4e74cfe71a96","BoxGeometry","width","height","depth","segments","min","super","geometry2","this","toNonIndexed","index","attributes","position","uv","box","divideScalar","subScalar","positions","array","normals","uvs","faceTris","length","halfSegmentSize","i","j","fromArray","x","y","z","floor","set"],"version":3,"file":"characterMovement.2a378562.js.map"}